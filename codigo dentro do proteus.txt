;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   qui ago 17 2017
; Processor: 8086
; Compiler:  MASM32
;
; Before starting simulation set Internal Memory Size 
; in the 8086 model properties to 0x10000
;====================================================================

; #####################################################################
; segmento do programa principal (o segmento de dados não foi criado)
CODIGO SEGMENT PARA 'CODE'
       ASSUME CS:CODIGO
       ASSUME ES:CODIGO         
   
   ; inicia programa no endereço especificado
   ORG 0100h 
   JMP START 
   
   ; seta endereços das portas e controle do CI 8255
   PORTAA	equ	4000h
   PORTAB	equ	4002h
   PORTAC	equ	4004h

   ; constantes dos delays utilizados
   DELAY_1S	equ	 45450d
   DELAY_20ms	equ      909d
   DELAY_5ms    equ      230d
   DELAY_500us  equ	 25d
   
   ; strings em geral            

   a1  		DB 'LINGUAGEM DE$'
   a2  		DB 'MONTAGEM$'
   erro1	DB '#INF!$'
   erro2	DB '#DIV/0$'
   b0		DB '0$'
   b1		DB '1$'
   b2		DB '2$'
   b3		DB '3$'
   b4		DB '4$'
   b5		DB '5$'
   b6		DB '6$'
   b7		DB '7$'
   b8		DB '8$'  
   b9		DB '9$'
   b10		DB '-$'
   b11		DB '/$'
   b12		DB '=$'
   b13		DB '+$'
   b14		DB '*$'
   resp 	DB '$'
   
   
   ; tabela de códigos da varredura do teclado (código, tecla ASCII)

	       
   ; início
   START: 
	    ; desabilita as interrupções
	    CLI
	    ; tamanho do offset do segmento de pilha em relação ao SP (x 010h)
	    MOV AX,00000h
	    MOV SS,AX
	    
	    ; seta endereço de início do segmento da pilha - 0FFFFh
	    MOV AX,10000h
	    MOV SP,AX
	    
	    ; inicializa registrador de segmento de código - 00000h
	    MOV AX,00000h
	    MOV CS,AX    
	    
	    CALL INIT_IO  
	    CALL INIT_LCD      
	    
	    ; chama rotina principal
	    CALL MAIN
   	 
      ; #####################################################################
      ; programa principal
   MAIN:	      	
	 ; habilita as interrupções
	 STI       
	 ; varredura do teclado
	 LMAIN:  
	    push BX
	    push DX
	    MOV AH, 0E0H
	    CALL OUT_PORTC
	    MOV CX, DELAY_20ms
	    CALL DELAY
	    MOV AH, 0D0H
	    CALL OUT_PORTC
	    MOV CX, DELAY_20ms
	    CALL DELAY
	    MOV AH, 0B0H
	    CALL OUT_PORTC
	    MOV CX, DELAY_20ms
	    CALL DELAY
	    MOV AH, 070H
	    CALL OUT_PORTC
	    MOV CX, DELAY_20ms
	    CALL DELAY	   
	    JMP LMAIN
	    POP DX
	    POP BX
	 RET
      
      ; #####################################################################
      ; rotina de inicialização do CI 8255A
   INIT_IO PROC NEAR
	    push AX
	    push DX
	    MOV DX, 4006H			; Valores tem que estar todos em 1
	    MOV AX, 081H			; VALOR DO FABRICANTE PARA CONFIGURAR A PC MEIA ENTRADA E MEIA SAIDA
	    OUT DX, AX
	    pop DX
	    pop AX
	    RET     
   INIT_IO ENDP
      
   OUT_PORTA PROC NEAR
	    push AX
	    push DX
	    MOV AL, AH			; O VALOR DO BYTE PARA SAIR DEVE ESTAR EM AH
	    MOV DX, PORTAA
	    OUT DX, AL
	    pop DX
	    pop AX
	    RET
   OUT_PORTA ENDP
   
   OUT_PORTB PROC NEAR
	    push AX
	    push DX
	    MOV AL, AH
	    MOV DX, PORTAB
	    OUT DX, AL
	    pop DX
	    pop AX
	    RET
   OUT_PORTB ENDP

   OUT_PORTC PROC NEAR 		; PERGUNTAR SOBRE A DIVISÃO DA PORTA
	    push AX
	    push DX
	    MOV AL, AH
	    MOV DX, PORTAC
	    OUT DX, AL
	    pop DX
	    pop AX 
	    RET
   OUT_PORTC ENDP

   IN_PORTC PROC NEAR 
	  ; push AX
	    push DX
	    MOV DX, 4004H
	    IN AL, DX
	    pop DX
	  ;  pop AX 
	    RET
   IN_PORTC ENDP      
   
      ; #####################################################################   
      ; procedimento de delay - CX = 0001h = 22 us (1MHz)
      ; o número de interações deve estar carregado no registrador CX
   DELAY PROC NEAR
	    push CX
   L_DELAY: 
	    JCXZ END_D
	    LOOP L_DELAY
   END_D:   pop CX
	    RET
   DELAY ENDP    
   
      ; #####################################################################
      ; procedimento que inicializa o display LCD
      ; display LCD 16x2
      INIT_LCD PROC NEAR 
	    push AX
	    push DX
	    MOV AH, 00H
	    CALL OUT_PORTB
	    MOV CX, DELAY_20ms
	    CALL DELAY
	    MOV AH, 038H
	    CALL COMANDO_LCD
	    MOV AH, 0CH
	    CALL COMANDO_LCD
	    MOV AH, 06H
	    CALL COMANDO_LCD
	    MOV AH, 01H
	    CALL COMANDO_LCD
	    MOV CX, DELAY_5ms		; TEMPO PARA 5 ms
	    CALL DELAY
	    pop DX
	    pop AX
	    RET	    
	INIT_LCD ENDP
      
      ; #####################################################################
      ; procedimento que envia um comando para o display LCD
      ; o caracter de comando deve estar no registrador AH
   COMANDO_LCD PROC NEAR
	    push AX
	    push CX
	    CALL OUT_PORTA
	    MOV AH, 04H
	    CALL OUT_PORTB	 
	    MOV CX, DELAY_500us
	    CALL DELAY
	    MOV AH, 00H
	    CALL OUT_PORTB
	    pop CX
	    pop AX
	    RET
   COMANDO_LCD ENDP

      ; #####################################################################
      ; procedimento que escreve um caracter no display LCD
      ; o caracter deve estar no registrador AH em código ASCII]
      
   ESCREVE_LCD PROC NEAR
	    push AX
	    push CX
	    CALL OUT_PORTA
	    MOV AH, 05H
	    CALL OUT_PORTB	 
	    MOV CX, DELAY_500us
	    CALL DELAY
	    MOV AH, 01H
	    CALL OUT_PORTB
	    pop CX
	    pop AX
	    RET
   ESCREVE_LCD ENDP
   
      ; #####################################################################
      ; procedimento que escreve um conjunto de caracteres no display LCD
      ; o endereço de memória de início da string deve estar no registrador SI
      ; toda string deve conter o terminador '$'
      
   TXT_LCD PROC NEAR         
	 push AX
	 CLD
   M:    LODSB
	 CMP AL, '$'
	 JZ E_T
	 MOV AH, AL      
	 CALL ESCREVE_LCD      
	 JMP M
   E_T:  pop AX
	 RET
   TXT_LCD ENDP
      
      ; #####################################################################
      ; procedimento que limpa o display LCD
   CLEAR_LCD PROC NEAR
	 push AX
	 push CX
	 MOV AH, 01H
	 CALL COMANDO_lCD
	 MOV CX, DELAY_5ms
	 CALL DELAY 
	 pop CX
	 pop AX
	 RET
   CLEAR_LCD ENDP

      ; #####################################################################
      ; procedimento que posiciona o cursor do display LCD
      ; o registrador BX armazena as coordenadas
      ; BH = linha  - 01 e 02
      ; BL = coluna - 01 a 16
   CURSOR_POS_LCD PROC NEAR
	 push AX
	 push BX
	 CMP BH, 01H
	 JZ P_L
	 MOV AH, 0C0H
	 JMP S
   P_L:	 MOV AH, 080H
   S:	 DEC BL
	 ADD AH, BL
	 CALL COMANDO_LCD
	 pop BX
	 pop AX
	 RET	 
   CURSOR_POS_LCD ENDP

   ; #####################################################################
   ; procedimento que aciona o cursor do display LCD
   CURSOR_ON_LCD PROC NEAR
	 push AX
	 MOV AH, 0FH
	 CALL COMANDO_LCD
	 pop AX
	 RET   
   CURSOR_ON_LCD ENDP
   
   ; #####################################################################
   ; procedimento que oculta o cursor do display LCD
   CURSOR_OFF_LCD PROC NEAR
	 push AX
	 MOV AH, 0CH
	 CALL COMANDO_LCD
	 pop AX
	 RET	 
   CURSOR_OFF_LCD ENDP
      
      ; #####################################################################
      ; procedimento de análise de teclas
      ; o código de entrada do teclado estará disponível na posição de memória PORTC_VAL
      ; a tecla pressionada estará disponível na posição de memória TECLA
      TECLADO PROC NEAR
      
	 ; * insira seu código aqui *
	 
      TECLADO ENDP 
      
      ; #####################################################################
      ; trata a interrupção do teclado e armazena programa da calculadora
      ORG 00008h	; endereço da interrupção NMI 
      DW  04000h	; endereço da subrotina a ser executada (valor do registrador IP)
      DW  00000h	; endereço do registrador de segmento de código - CS
      ORG 04000h	; endereço da subrotina
      KEY_INT:		; rótulo da interrupção
	 
	 ; desabilita interrupções
	 CLI
	 CALL IN_PORTC
	 CMP AL,0E7H
	 JNZ NAO14
	 MOV DX,00001H
	 MOV BX,00000H
	 JMP ASD
NAO14:	 CMP AL,07BH		;-
	 JNZ NAO10
	 MOV DX,0010D
	 LEA SI, b10
	 JMP ASD
NAO10:	 CMP AL,07EH		;/
	 JNZ NAO11
	 MOV DX,0011D
	 LEA SI, b11
	 JMP ASD
NAO11:	 CMP AL,0B7H		;=
	 JNZ NAO12
	 MOV DX,0012D
	 LEA SI, b12
	 JMP ASD
NAO12:	 CMP AL,077H		;+
	 JNZ NAO13
	 MOV DX,0013D
	 LEA SI, b13
	 JMP ASD
NAO13:	 CMP AL,07DH		;*
	 JNZ NAO9
	 MOV DX,14D
	 LEA SI, b14
	 JMP ASD
NAO9:	 CMP AL,0BEH
	 JNZ NAO8
	 CMP BX,0D
	 JZ SOMA9
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA9:	 ADD BX,9H
	 LEA SI,b9
	 JMP ASD
NAO8:	 CMP AL,0DEH
	 JNZ NAO7
	 CMP BX,0D
	 JZ SOMA8
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA8:	 ADD BX,8H
	 LEA SI,b8
	 JMP ASD
NAO7:	 CMP AL,0EEH
	 JNZ NAO6
	 CMP BX,0D
	 JZ SOMA7
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA7:	 ADD BX,7H
	 LEA SI,b7
	 JMP ASD
NAO6:	 CMP AL,0BDH
	 JNZ NAO5	
	 CMP BX,0D
	 JZ SOMA6
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA6:	 ADD BX,6H
	 LEA SI,b6
	 JMP ASD
NAO5:	 CMP AL,0DDH
	 JNZ NAO4
	 CMP BX,0D
	 JZ SOMA5
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA5:   ADD BX,5H
	 LEA SI,b5
	 JMP ASD
NAO4:	 CMP AL,0EDH
	 JNZ NAO3
	 CMP BX,0D
	 JZ SOMA4
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA4:	 ADD BX,4H
	 LEA SI,b4
	 JMP ASD
NAO3:	 CMP AL,0BBH
	 JNZ NAO2
	 CMP BX,0D
	 JZ SOMA3
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA3:	 ADD BX,3H
	 LEA SI,b3
	 JMP ASD
NAO2:	 CMP AL,0DBH
	 JNZ NAO1
	 CMP BX,0D
	 JZ SOMA2
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA2:	 ADD BX,2H
	 LEA SI, b2
	 JMP ASD
NAO1:	 CMP AL,0EBH
	 JNZ NAO0
	 CMP BX,0D
	 JZ SOMA1
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA1:	 ADD BX,1H
	 LEA SI,b1
	 JMP ASD
NAO0:	 CMP AL,0D7H
	 JNZ ASD
	 CMP BX,0D
	 JZ SOMA0
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA0:	 ADD BX,0H
	 LEA SI,b0
	 JMP ASD
ASD: 	 CALL TXT_LCD
	 MOV DX,AX
FICA_AE: push DX
	 CALL IN_PORTC
	 CMP DX,AX
	 POP DX
	 JZ FICA_AE
	 CMP DX,13D
	 JNZ SAI
	 MOV DL,RESP
	 ADD resp,48D
	 LEA SI,resp
	 CALL TXT_LCD
SAI:
	 ; * insira seu código aqui *
	    
	 ; habilita interrupções
	 STI
      
      ; indica retorna da interrupção
      IRET

   CODIGO ENDS
       END START