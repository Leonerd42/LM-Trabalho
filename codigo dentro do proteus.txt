;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   qui ago 17 2017
; Processor: 8086
; Compiler:  MASM32
;
; Before starting simulation set Internal Memory Size 
; in the 8086 model properties to 0x10000
;====================================================================

; #####################################################################
; segmento do programa principal (o segmento de dados não foi criado)
CODIGO SEGMENT PARA 'CODE'
       ASSUME CS:CODIGO
       ASSUME ES:CODIGO         
   
   ; inicia programa no endereço especificado
   ORG 0100h 
   JMP START 
   
   ; seta endereços das portas e controle do CI 8255
   PORTAA	equ	4000h
   PORTAB	equ	4002h
   PORTAC	equ	4004h

   ; constantes dos delays utilizados
   DELAY_1S	equ	 45450d
   DELAY_20ms	equ      909d
   DELAY_5ms    equ      230d
   DELAY_500us  equ	 25d
   
   ; strings e variaveis           

   a1  		DB 'LINGUAGEM DE$'
   a2  		DB 'MONTAGEM$'
   erro1	DB '#INF!$'
   erro2	DB '#DIV/0$'
   NUM		DB 0D
   IGUAL	DB 0D
   b0		DB '0$'
   b1		DB '1$'
   b2		DB '2$'
   b3		DB '3$'
   b4		DB '4$'
   b5		DB '5$'
   b6		DB '6$'
   b7		DB '7$'
   b8		DB '8$'  
   b9		DB '9$'
   b10		DB '-$'
   b11		DB '/$'
   b12		DB '=$'
   b13		DB '+$'
   b14		DB '*$'
   resp 	DB '$'
   valor1	DW 0H
   C1		DB 0H
   C2		DB 0H
   C3		DB 0H
   C4		DB 0H
   C5		DB 0H
   ligado	DB 0H	;QND FOR 0 O VISOR ESTA DESLIGADO, QND FOR 1 ESTA LIGADO E SEM NADA ESCRITO, QND FOR 2 TEM ALGO ESCRITO
   CONTA	DB 0H	;verifica o numero de vezes que as instruçoes + - * / foram pressionadas
   MENOR	DB 0H	;SINALIZA NUMERO NEGATIO
   INVA		DB 0H	;PARA QUANDO NAO É VALIDO O VALOR
			;1 PARA NUMERO ACIMA DO PERMITIDO E 2 PARA DIVISAO POR 0
   
   
   ; tabela de códigos da varredura do teclado (código, tecla ASCII)

	       
   ; início
   START: 
	    ; desabilita as interrupções
	    CLI
	    ; tamanho do offset do segmento de pilha em relação ao SP (x 010h)
	    MOV AX,00000h
	    MOV SS,AX
	    
	    ; seta endereço de início do segmento da pilha - 0FFFFh
	    MOV AX,10000h
	    MOV SP,AX
	    
	    ; inicializa registrador de segmento de código - 00000h
	    MOV AX,00000h
	    MOV CS,AX    
	    
	    CALL INIT_IO  
	    CALL INIT_LCD      
	    
	    ; chama rotina principal
	    CALL MAIN
   	 
      ; #####################################################################
      ; programa principal
   MAIN:	      	
	 ; habilita as interrupções
	 STI       
	 ; varredura do teclado
	 LMAIN:  
	    push BX
	    push DX
	    MOV AH, 0E0H
	    CALL OUT_PORTC
	    MOV CX, DELAY_20ms
	    CALL DELAY
	    MOV AH, 0D0H
	    CALL OUT_PORTC
	    MOV CX, DELAY_20ms
	    CALL DELAY
	    MOV AH, 0B0H
	    CALL OUT_PORTC
	    MOV CX, DELAY_20ms
	    CALL DELAY
	    MOV AH, 070H
	    CALL OUT_PORTC
	    MOV CX, DELAY_20ms
	    CALL DELAY	   
	    JMP LMAIN
	    POP DX
	    POP BX
	 RET
      
      ; #####################################################################
      ; rotina de inicialização do CI 8255A
   ;----exercicio 1
   INIT_IO PROC NEAR
	    push AX
	    push DX
	    MOV DX, 4006H			; Valores tem que estar todos em 1
	    MOV AX, 081H			; VALOR DO FABRICANTE PARA CONFIGURAR A PC MEIA ENTRADA E MEIA SAIDA
	    OUT DX, AX
	    pop DX
	    pop AX
	    RET     
   INIT_IO ENDP
      ;----fim do ex1
 
;-----ex2 
  OUT_PORTA PROC NEAR
	    push AX
	    push DX
	    MOV AL, AH			; O VALOR DO BYTE PARA SAIR DEVE ESTAR EM AH
	    MOV DX, PORTAA
	    OUT DX, AL
	    pop DX
	    pop AX
	    RET
   OUT_PORTA ENDP
   
   OUT_PORTB PROC NEAR
	    push AX
	    push DX
	    MOV AL, AH
	    MOV DX, PORTAB
	    OUT DX, AL
	    pop DX
	    pop AX
	    RET
   OUT_PORTB ENDP

   OUT_PORTC PROC NEAR 		
	    push AX
	    push DX
	    MOV AL, AH
	    MOV DX, PORTAC
	    OUT DX, AL
	    pop DX
	    pop AX 
	    RET
   OUT_PORTC ENDP

   IN_PORTC PROC NEAR 
	  ; push AX
	    push DX
	    MOV DX, 4004H
	    IN AL, DX
	    pop DX
	  ;  pop AX 
	    RET
   IN_PORTC ENDP      
   ;--------------fim do ex2
   
   ; #####################################################################   
      ; procedimento de delay - CX = 0001h = 22 us (1MHz)
      ; o número de interações deve estar carregado no registrador CX
   
   ;---ex3
   DELAY PROC NEAR
	    push CX
   L_DELAY: 
	    JCXZ END_D
	    LOOP L_DELAY
   END_D:   pop CX
	    RET
   DELAY ENDP    
   ;------fim do ex3
   
      ; #####################################################################
      ; procedimento que inicializa o display LCD
      ; display LCD 16x2

      ;---ex6
      INIT_LCD PROC NEAR 
	    push AX
	    push DX
	    MOV AH, 00H ;a-limpar o barramento de ocntrole do display
	    ;enable =0, rw = 0 e rs=0
	    CALL OUT_PORTB ;b - escreve o dado na portB
	    MOV CX, DELAY_20ms ;c-aguarda
	    CALL DELAY
	    MOV AH, 038H ;d-enviar comando 38h ao display
	    CALL COMANDO_LCD
	    MOV AH, 0CH ;e -enviar comando OCh ao display
	    ;-pra configurar o cursos
	    CALL COMANDO_LCD
	    MOV AH, 06H;f-enviar comando 06h ao display
	                  ;cursor vai para direita
	    CALL COMANDO_LCD
	    MOV AH, 01H ;g- limpar a tela com o comando 01h
	    CALL COMANDO_LCD
	    MOV CX, DELAY_5ms		; TEMPO PARA 5 ms
	    CALL DELAY
	    pop DX
	    pop AX
	    RET	    
	INIT_LCD ENDP
      ;------- fim do ex6
      
      ; #####################################################################
      ; procedimento que envia um comando para o display LCD
      ; o caracter de comando deve estar no registrador AH

      ;---ex4
      COMANDO_LCD PROC NEAR
	    push AX
	    push CX
	    CALL OUT_PORTA
	    MOV AH, 04H
	    CALL OUT_PORTB	 
	    MOV CX, DELAY_500us
	    CALL DELAY
	    MOV AH, 00H
	    CALL OUT_PORTB
	    pop CX
	    pop AX
	    RET
   COMANDO_LCD ENDP
;-----fim do ex4
   
      ; #####################################################################
      ; procedimento que escreve um caracter no display LCD
      ; o caracter deve estar no registrador AH em código ASCII]
      
 ;---ex5     
   ESCREVE_LCD PROC NEAR
	    push AX
	    push CX
	    CALL OUT_PORTA  ;a-carregar caracter no barramento de dados do display
	    MOV AH, 05H
	    CALL OUT_PORTB ;c- escreva o dado no PORTB	 
	    MOV CX, DELAY_500us ;d-aguarda 500
	    CALL DELAY
	    MOV AH, 01H ;aqui so pode ser e- desabilitar o lcd do modo escrita
	   ;ou seja enable = 0 .. 
	   CALL OUT_PORTB ;f- escreve novo dado
	    pop CX
	    pop AX
	    RET
   ESCREVE_LCD ENDP
   ;------fim do ex5
   
      ; #####################################################################
      ; procedimento que escreve um conjunto de caracteres no display LCD
      ; o endereço de memória de início da string deve estar no registrador SI
      ; toda string deve conter o terminador '$'
      
      ;---ex8
   TXT_LCD PROC NEAR         
	 push AX
	 CLD ;c- loop de impressao
   M:    LODSB; - - loop de impressao
	 CMP AL, '$' ; simbolo terminador da string
	 JZ E_T
	 MOV AH, AL      
	 CALL ESCREVE_LCD      
	 JMP M
   E_T:  pop AX
	 RET
   TXT_LCD ENDP
      ;-------fim do ex8
    
    ; #####################################################################
      ; procedimento que limpa o display LCD
   
   ;--ex7
   CLEAR_LCD PROC NEAR
	 push AX
	 push CX
	 MOV AH, 01H ; o comando 01h limpa a tela
	 CALL COMANDO_lCD
	 MOV CX, DELAY_5ms
	 CALL DELAY 
	 pop CX
	 pop AX
	 RET
   CLEAR_LCD ENDP
;----fim do ex7

      ; #####################################################################
      ; procedimento que posiciona o cursor do display LCD
      ; o registrador BX armazena as coordenadas
      ; BH = linha  - 01 e 02
      ; BL = coluna - 01 a 16
  
;--ex9 
 CURSOR_POS_LCD PROC NEAR
	 push AX
	 push BX ;bx é o operando de entrada aqui
	 CMP BH, 01H ;bh linha
	 ;-se bh=1 carregar ah com 80h
	 JZ P_L
	 MOV AH, 0C0H ;;se bh=2 carrega com och
	 JMP S
   P_L:	 MOV AH, 080H
   S:	 DEC BL ;bl coluna 
	 ADD AH, BL
	 CALL COMANDO_LCD ;enviar pro display o valor final de AH
	 pop BX
	 pop AX
	 RET	 
   CURSOR_POS_LCD ENDP
;---------fim do ex9
   
   ; #####################################################################
   ; procedimento que aciona o cursor do display LCD
   CURSOR_ON_LCD PROC NEAR
	 push AX
	 MOV AH, 0FH
	 CALL COMANDO_LCD
	 pop AX
	 RET   
   CURSOR_ON_LCD ENDP
   
   ; #####################################################################
   ; procedimento que oculta o cursor do display LCD
   CURSOR_OFF_LCD PROC NEAR
	 push AX
	 MOV AH, 0CH
	 CALL COMANDO_LCD
	 pop AX
	 RET	 
   CURSOR_OFF_LCD ENDP
      
      ; #####################################################################
      ; procedimento de análise de teclas
      ; o código de entrada do teclado estará disponível na posição de memória PORTC_VAL
      ; a tecla pressionada estará disponível na posição de memória TECLA
      CALCULO PROC NEAR
      
	JMP OI
OP_MUL: 
	 push DX
	 MOV DX,0H
	 MOV AX, valor1
	 MUL BX
	 CMP DX,0D
	 JZ OP_MUL2	;PULA SE A MULTIPLICAÇAO NAO ESTOURAR O AX
	 CALL OVERFLOW
OP_MUL2: MOV BX,AX
	 POP DX
	 JMP Endd
OP_DIV: 
	 push DX
	 MOV DX,0H
	 MOV AX, valor1
	 CMP BX,0D
	 JZ INVALIDO
	 DIV BX
	 MOV BX,AX
	 JMP VALEU
INVALIDO:MOV INVA,2D	 
VALEU:	 POP DX 
	 JMP Endd
OP_SOMA: 
	 MOV AX, valor1
	 ADD BX,AX
	 JNC OP_SOMA2
	 CALL OVERFLOW
OP_SOMA2:
	 JMP Endd
OP_SUB: 
	 MOV AX,valor1
	 push CX
	 push DX
	 MOV DX,0FFFFH
	 MOV CX,0FFFFH
	 MOV DL,AH
	 MOV CL,BH
	 CMP DX,CX
	 JZ POSITIVO0
	 JNL POSITIVO1
	 MOV MENOR,1D
	 JMP POSITIVO1
POSITIVO0: CMP AL,BL
	 JNL POSITIVO1
	 MOV MENOR,1D
POSITIVO1: SUB AX,BX
	 MOV BX,AX
	 POP DX
	 POP CX
	 JMP Endd

OI:
	       push AX
	       CMP CONTA, 10D
	       JZ OP_SUB
	       CMP CONTA, 11D
	       JZ OP_DIV
	       CMP CONTA, 13D
	       JZ OP_SOMA
	       CMP CONTA, 14D
	       JZ OP_MUL
Endd:
      POP AX
      RET
	 
      CALCULO ENDP
     
    
    
      ;----------------------------------------
      OVERFLOW PROC NEAR 
      MOV INVA,01D
      RET
      OVERFLOW ENDP
   ;----------------------------------   
      
      
	 ESCREVE_RESP PROC NEAR
	    CLI
	   push AX
	   push DX
	   push BX
	   push BX
	   MOV BX,020BH
	   CALL CURSOR_POS_LCD
	   POP BX
	   CMP INVA,02H
	   JNZ VAL0	;DIVISAO POR 0
	   LEA SI,erro2
	   CALL TXT_LCD
	   JMP EEEND
VAL0:	   CMP INVA,01H
	   JNZ VAL1	;NUMERO GRANDE
	   LEA SI,erro1
	   CALL TXT_LCD
	   JMP EEEND
VAL1:	   CMP MENOR,1H		;NUMERO NEGATIVO
	   JNZ VAL2
	   MOV AH,45D
	   CALL ESCREVE_LCD
	   MOV AX,0FFFFH
	   SUB AX,BX
	   MOV BX,AX
	   INC BX
VAL2:	   MOV AX,BX
	   MOV BX,10000D
	   MOV DX,0D
	   DIV BX
	   MOV C1,AL
	   MOV AX,DX
	   MOV BX,1000D
	   MOV DX,0D
	   DIV BX
	   MOV C2,AL
	   MOV AX,DX
	   MOV BX,100D
	   MOV DX,0D
	   DIV BX
	   MOV C3,AL
	   MOV AX,DX
	   MOV BX,10D
	   MOV DX,0D
	   DIV BX
	   MOV C4,AL
	   MOV C5,DL
	   MOV AL,C1
	   CMP AL,0D
	   JNZ DIG5	;5 DIGITOS
	   MOV AL,C2	;FIZ 5 LUGARES DIFERENTES PARA DEIXAR O ESPAÇO EM BRANCO E DEIXAR OS NUMERO ENCOSTANDO NO FIM 
	   CMP AL,0D
	   JNZ DIG4
	   MOV AL,C3
	   CMP AL,0D
	   JNZ DIG3
	   MOV AL,C4
	   CMP AL,0D
	   JNZ DIG2
	   JP  DIG1
DIG5:	MOV AH,C1
	ADD AH,48D
        CALL ESCREVE_LCD
	MOV AH,C2
	ADD AH,48D
        CALL ESCREVE_LCD
	MOV AH,C3
	ADD AH,48D
        CALL ESCREVE_LCD
	MOV AH,C4
	ADD AH,48D
        CALL ESCREVE_LCD
	MOV AH,C5
	ADD AH,48D
        CALL ESCREVE_LCD
	JMP EEEND
DIG4:	MOV AH,C1
        CALL ESCREVE_LCD
	MOV AH,C2
	ADD AH,48D
        CALL ESCREVE_LCD
	MOV AH,C3
	ADD AH,48D
        CALL ESCREVE_LCD
	MOV AH,C4
	ADD AH,48D
        CALL ESCREVE_LCD
	MOV AH,C5
	ADD AH,48D
        CALL ESCREVE_LCD
	JMP EEEND
DIG3:	MOV AH,C1
        CALL ESCREVE_LCD
	MOV AH,C2
        CALL ESCREVE_LCD
	MOV AH,C3
	ADD AH,48D
        CALL ESCREVE_LCD
	MOV AH,C4
	ADD AH,48D
        CALL ESCREVE_LCD
	MOV AH,C5
	ADD AH,48D
        CALL ESCREVE_LCD
	JMP EEEND
DIG2:	MOV AH,C1
        CALL ESCREVE_LCD
	MOV AH,C2
        CALL ESCREVE_LCD
	MOV AH,C3
        CALL ESCREVE_LCD
	MOV AH,C4
	ADD AH,48D
        CALL ESCREVE_LCD
	MOV AH,C5
	ADD AH,48D
        CALL ESCREVE_LCD
	JMP EEEND
DIG1:	MOV AH,C1
        CALL ESCREVE_LCD
	MOV AH,C2
        CALL ESCREVE_LCD
	MOV AH,C3
        CALL ESCREVE_LCD
	MOV AH,C4
        CALL ESCREVE_LCD
	MOV AH,C5
	ADD AH,48D
        CALL ESCREVE_LCD
	JMP EEEND
	
EEEND:
	   POP BX
	   POP DX
	   POP AX
	   RET
 
	 ESCREVE_RESP ENDP
      
      ; #####################################################################
      ; trata a interrupção do teclado e armazena programa da calculadora
      ORG 00008h	; endereço da interrupção NMI 
      DW  04000h	; endereço da subrotina a ser executada (valor do registrador IP)
      DW  00000h	; endereço do registrador de segmento de código - CS
      ORG 04000h	; endereço da subrotina
      KEY_INT:		; rótulo da interrupção
	 
	 ; desabilita interrupções
	 CLI
	 CALL IN_PORTC
	 CMP AL,0E7H
	 JNZ NAO14
	 MOV DX,00001H
	 MOV BX,00000H
	 MOV IGUAL,0D
	 MOV MENOR,0H
	 MOV INVA,0H
	 MOV NUM,0H
	 MOV CONTA,0D
	 MOV valor1,0H
	 CMP ligado,01D
	 JNZ ZERA
	    CALL CURSOR_OFF_LCD
	    MOV ligado,0D
	    JMP ON
ZERA:	 CALL CURSOR_ON_LCD
	 MOV ligado,1D
	 JMP ON
NAO14:	 CMP ligado,0D
	 JZ SAI
	 MOV ligado,02d		;MARCA QUE ALGO ESTA ESCRITO (SO CHEGA AQUI SE NA TIVER PRESSIOANDO O ON
	 CMP AL,07BH		;-
	 JNZ NAO10
	 MOV CONTA,10D
	 INC NUM
	 MOV DH,00D
	 LEA SI, b10
	 JMP OPE
NAO10:	 CMP AL,07EH		;/
	 JNZ NAO11
	 MOV CONTA,11D
	 MOV DH,00D
	 INC NUM
	 LEA SI, b11
	 JMP OPE
NAO11:	 CMP AL,0B7H		;=
	 JNZ NAO12
	 MOV IGUAL,12D
	 LEA SI, b12
	 JMP ASD3
NAO12:	 CMP AL,077H		;+
	 JNZ NAO13
	 MOV CONTA,13D
	 INC NUM
	 MOV DH,00D
	 LEA SI, b13
	 JMP OPE
NAO13:	 CMP AL,07DH		;*
	 JNZ NAO9
	 MOV CONTA,14D
	 INC NUM
	 MOV DH,00D
	 LEA SI, b14
	 JMP OPE
NAO9:	 push DX		;DX É USADO NA MULTIPLICAÇAO, SERVE PARA O OVERFLOW 
	 MOV DX,0D
	 CMP AL,0BEH
	 JNZ NAO8
	 CMP BX,0D
	 JZ SOMA9
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX			;salva o valor em BX
	 POP AX
SOMA9:	 ADD BX,9H
	 JNC CONT9
	 CALL OVERFLOW
CONT9:	 LEA SI,b9
	 JMP ASD
NAO8:	 CMP AL,0DEH
	 JNZ NAO7
	 CMP BX,0D
	 JZ SOMA8
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA8:	 ADD BX,8H
	 JNC CONT8
	 CALL OVERFLOW
CONT8:	 LEA SI,b8
	 JMP ASD
NAO7:	 CMP AL,0EEH
	 JNZ NAO6
	 CMP BX,0D
	 JZ SOMA7
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA7:	 ADD BX,7H
	 JNC CONT7
	 CALL OVERFLOW
CONT7:	 LEA SI,b7
	 JMP ASD
NAO6:	 CMP AL,0BDH
	 JNZ NAO5	
	 CMP BX,0D
	 JZ SOMA6
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA6:	 ADD BX,6H
	 JNC CONT6
	 CALL OVERFLOW
CONT6:	 LEA SI,b6
	 JMP ASD
NAO5:	 CMP AL,0DDH
	 JNZ NAO4
	 CMP BX,0D
	 JZ SOMA5
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA5:   ADD BX,5H
	 LEA SI,b5
	 JMP ASD
NAO4:	 CMP AL,0EDH
	 JNZ NAO3
	 CMP BX,0D
	 JZ SOMA4
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA4:	 ADD BX,4H
	 LEA SI,b4
	 JMP ASD
NAO3:	 CMP AL,0BBH
	 JNZ NAO2
	 CMP BX,0D
	 JZ SOMA3
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA3:	 ADD BX,3H
	 LEA SI,b3
	 JMP ASD
NAO2:	 CMP AL,0DBH
	 JNZ NAO1
	 CMP BX,0D
	 JZ SOMA2
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA2:	 ADD BX,2H
	 LEA SI, b2
	 JMP ASD
NAO1:	 CMP AL,0EBH
	 JNZ NAO0
	 CMP BX,0D
	 JZ SOMA1
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA1:	 ADD BX,1H
	 LEA SI,b1
	 JMP ASD
NAO0:	 CMP AL,0D7H
	 JNZ ASD
	 CMP BX,0D
	 JZ SOMA0
	 push AX
	 MOV AX,10D
	 MUL BX
	 MOV BX,AX
	 POP AX
SOMA0:	 ADD BX,0H
	 LEA SI,b0
	 JMP ASD
OPE:	 MOV valor1,BX		;PARA QUANDO PRESSIONA + - / OU *
	 MOV BX,0D
	 JMP ASD3
ON:	 CALL CLEAR_LCD		;INICIA O LCD
	 JMP ASD2
ASD: 	 CMP DX,0D
	 JZ NAO_OVER
	 CALL OVERFLOW
NAO_OVER: POP DX
ASD3:	CALL TXT_LCD		;ESCREVE A TECLA PRESSIONADA
ASD2:	 push DX
	 MOV DX,AX
FICA_AE: push DX		;LOOP PARA TRAVAR ATE SOLTAR A TECLA
	 CALL IN_PORTC
	 CMP DX,AX
	 POP DX
	 JZ FICA_AE
	 POP DX
	 CMP IGUAL,12D
	 JNZ SAI
	 push AX
	 MOV AL,01D
	 CMP AL,NUM
	 JNC AQUI		;COMPARA SE TEM MAIS DE 2 TERMOS
	 CALL OVERFLOW
AQUI:	 POP AX
	 CALL CALCULO
	 MOV ligado,0d
	 CALL ESCREVE_RESP
	
	
SAI:
	 ; * insira seu código aqui *
	    
	 ; habilita interrupções
	 STI
      
      ; indica retorna da interrupção
      IRET

   CODIGO ENDS
       END START